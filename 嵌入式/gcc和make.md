## GCC

### GCC编译工具链（toolchain）

- gcc-core：即GCC编译器，用于完成预处理和编译过程，例如把C代码转换成汇编代码。

- Binutils ：除GCC编译器外的一系列小工具包括了链接器ld，汇编器as、目标文件格式查看器readelf等。

  - 常用工具

    - as：汇编器，把汇编语言代码转换为机器码（目标文件）。
    - ld：链接器，把编译生成的多个目标文件组织成最终的可执行程序文件。
    - readelf：可用于查看目标文件或可执行程序文件的信息。
    - nm ： 可用于查看目标文件中出现的符号。
    - objcopy： 可用于目标文件格式转换，如.bin 转换成 .elf 、.elf 转换成 .bin等。
    - objdump：可用于查看目标文件的信息，最主要的作用是反汇编。
    - size：可用于查看目标文件不同部分的尺寸和总尺寸，例如代码段大小、数据段大小、使用的静态内存、总大小等。

    > ldd工具查看动态文件的库依赖

- glibc：包含了主要的 C语言标准函数库，C语言中常常使用的打印函数printf、malloc函数就在glibc 库中。

### 基本语法

```c
gcc [参数] [文件名]
    
-c 编译、汇编到目标代码（.o），不链接成可执行文件
-g 生成调试信息
-o 编译完成后生成的文件名，如果不使用该选项，默认生成a.out 文件
-O 对程序进行优化编译，产生的可执行文件执行效率高
-w 不生成任何警告
-S 仅编译到汇编语言，不进行汇编和链接
```

### 编译流程

1. 预处理，生成预编译文件（.文件）
2. 编译，生成汇编代码（.S 文件）
3. 汇编，生成目标文件（.o 文件）
4. 链接，生成可执行文件

### 本地编译

编译器和目标程序都是相同架构的编译过程，被称为 **本地编译** 。

### 交叉编译

编译器和目标程序运行在不同架构的编译过程，被称为 **交叉编译**。

### 搭建交叉编译环境



### 交叉编译器（Cross compiler

- arm-linux-gnueabihf-gcc：名称中的Linux表示目标应用程序是运行在Linux操作系统之上的，例如前面的hello.c程序。
- arm-none-eabi-gcc，名称中的none表示无操作系统，目标应用程序的运行环境是不带操作系统的，例如裸机代码、uboot、内核代码本身。

命名规则

arch [-os] [-(gnu)eabi(hf)] -gcc

| 字段 | 含义           |
| ---- | -------------- |
| arch | 目标芯片架构   |
| os   | 操作系统       |
| gnu  | C标准库类型    |
| eabi | 应用二进制接口 |
| hf   | 浮点模式       |

## Makefile

> 参考文档：《跟我一起写Makefile》

文件名必须是==Makefile==,区分大小写

Makefile文件的规则

```c
target（目标文件） ...: prerequisites（依赖的文件） ...
command（命令）
...
...
```

Makefile文件中的缩进，必须用==Tab键==，不能用空格键。

Makefile优先执行第一条规则，根据第一条规则的依赖条件，执行后续的规则。

### Makefile的变量

Makefile中的变量引用方式"$(变量名)"

#### 变量的赋值符号

+ =
+ :=
+ ?=
+ +=

### Makefile条件判断

```c
1.
<条件比较>
[条件为真时执行的脚本]
endif
    
2.
<条件比较>
[条件为真时执行的脚本]
else
[条件为假时执行的脚本]
endif
```

#### 关键词

+ ifeq       如果比较相等
+ ifneq    如果比较不相等
+ ifdef     如果定义了变量
+ ifndef   如果没有定义变量

### 使用函数

```c
$(<函数名> <参数集合>)
或者：
${<函数名> <参数集合>}
```

函数名和参数集合之间用空格分隔，参数集合的参数通过逗号分隔

#### 常用函数介绍

##### subst函数

##### patsubst函数

##### strip函数

##### findstring函数

##### dir函数

##### notdir函数

##### foreach函数

### 使用通配符

+ *
+ ?
+ [...]